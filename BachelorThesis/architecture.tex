


\section{Architekturänderung}
\todo[]{Eigentlicher Kern der Arbeit, mache ich, sobald ich mit Prokrastination fertig bin.}
Im Folgenden wird die Planung und Implementierung der Architekturänderung zwecks Entkopplung der Z3-Komponente aus ProB beschrieben.

\subsection{Planung}

Um eine korrekte Systemrefaktorisierung durchzuführen, ist es notwendig, zuvor grundlegende Kernaspekte
des neuen Systems vollständig zu planen. Dies beinhaltet insbesondere die Struktur des neuen Server-Prozesses
und den Aufbau der Nachrichten, die zwischen den Prozessen ausgetauscht werden.

\subsubsection{Prolog Datentypen}

Innerhalb des bestehenden Z3-Interfaces werden verschiedene Prolog-Datentypen verwendet.
Da durch die Entkopplung der Prozesse Prolog selbst und die Z3-Komponente nicht länger direkt miteinander kommunizieren können,
müssen die Prolog-Datentypen in eine Form umgewandelt werden, die über das Netzwerk übertragen werden kann und von Z3 verstanden wird.
\todo[]{zitate zu deutsch oder so}
Primär werden die folgenden Prolog-Datentypen verwendet: SP\_atom, SP\_integer und SP\_term\_ref.
Mithilfe der C\texttt{++} Bibliothek SICStus Prolog können diese Datentypen konvertiert werden.
So stehen bei der Umwandlung von SP\_atom in einen C\texttt{++} String die Funktionen SP\_string\_to\_atom und SP\_atom\_to\_string zur Verfügung.
Die Dokumentation von SICStus Prolog \cite{sicstusdoc} schlägt unter dem Kapitel \enquote{Conversions between Prolog Arguments and C Types} zudem zur Umwandlung von SP\_integer den Datentyp C long vor.
Der Typ SP\_term\_ref wird in der Dokumentation wie folgt beschrieben: \enquote{The argument could be any term.}.
Er lässt sich nur schwer gezielt in einen C\texttt{++} Datentyp umwandeln und muss daher mit besonderer Vorsicht behandelt werden.

\subsubsection{Struktur der Nachrichten}

Innerhalb von ZeroMQ lassen sich verschiedene Datenwerte gemeinsam in einen Nachrichtenblock packen.
Ein solcher Nachrichtenblock wird über das abstrakte $zmsg$ Objekt repräsentiert, welches es ermöglicht,
komplexere Daten zusammen in sogenannten Frames zu übermitteln.
Da sich der konkrete Inhalt der Nachrichten je nach Interfacefunktion unterscheidet,
bietet es sich an, dieses Konzept zu nutzen und den Inhalt spezifisch für jede Funktion zu definieren und zu interpretieren.

Zusätzlich zu den eigentlichen Daten, die übermittelt werden, ist es jedoch notwendig, Metadaten zu übermitteln,
die die korrekte Interpretation der Nachrichten auf der Empfängerseite ermöglichen.
Wenn eine Anfragenachricht von ProB an den Z3-Server gesendet wird, muss der Server wissen, welche Funktion aufgerufen werden soll.
Dafür wird ein Funktionsidentifikator benötigt, der die Funktion eindeutig identifiziert.
Diese Identifikatoren werden als ein Enum-Typ definiert, der die verschiedenen Funktionen als Konstanten repräsentiert und in sowohl
der ProB- als auch der Z3-Komponente eingebunden wird.
Ein Ausschnitt des Enum-Typs ist in \cref{lst:func-identifiers} gezeigt.

\begin{lstlisting}[
    float, caption={Ein Ausschnitt des Funktionsidentifikations-Enums.}, label={lst:func-identifiers}, language=C++
  ]
  enum SP_Function {
    INIT = 0,
    PRETTY_PRINT_SMT = 1,
    PRETTY_PRINT_SMT_FOR_ID = 2,
    MK_VAR = 2,
    // ...
  }
\end{lstlisting}

Wenn eine Antwortnachricht vom Z3-Server an ProB gesendet wird, muss die Nachricht ebenfalls Metadaten enthalten,
die die korrekte Interpretation der Nachricht auf der ProB-Seite ermöglichen.
Dafür wird ein Statusidentifikator benötigt, der den Status der Anfrage repräsentiert.
Der hierfür verwendete Enum-Typ ist in \cref{lst:status-identifiers} gezeigt.

\begin{lstlisting}[
    float, caption={Das Statusidentifikations-Enum.}, label={lst:status-identifiers}, language=C++
  ]
  enum Z3Status {
    NOK,
    OK,
    UNFINISHED
  }
\end{lstlisting}

Die Statuswerte $OK$ und $NOK$ repräsentieren den Erfolg oder Misserfolg einer Anfrage.
Diese Werte sind fundamental, da bei dem Aufkommen von potenziellen Fehlern oder Exceptions (siehe \cref{sec:exceptions}) in Z3 der ProB Prozess über den Misserfolg informiert werden muss,
um eine entsprechende Fehlerbehandlung durchzuführen. 
Der Statuswert $UNFINISHED$ wird verwendet, wenn eine Anfrage noch nicht abgeschlossen ist und der Server auf weitere Informationen wartet (siehe \cref{subsec:helper-functions}).

Insgesamt besteht eine Nachricht also immer aus einem Identifikator (von Typ Integer), der entweder eine Funktion oder einen Status repräsentiert,
gefolgt von den eigentlichen Daten, die übermittelt werden sollen, in Form eines $zmsg$ Objektes.

\subsubsection{Server Struktur}

Da sich der Z3-Server mit nur einem einzigen Client beschäftigen muss, ist die Kernlogik des Servermodells simpel gehalten.
Nach dem Instanziieren des Sockets wird eine Endlosschleife gestartet, die auf eingehende Nachrichten wartet.
Sobald eine Nachricht empfangen wird, wird zunächst der Funktionsidentifikator extrahiert und die entsprechende Funktion aufgerufen.
Dies geschieht mittels einem Switch-Case-Block, der alle möglichen Funktionsidentifikatoren abdeckt.
Nachdem die Funktion, mit den aus dem $zmsg$ Objekt extrahierten Daten als Parameter ausgeführt wurde,
wird eine Antwortnachricht an den ProB-Prozess gesendet, die den Status der Anfrage und die Ergebnisse enthält.
Das Ergebnis ist in den meisten Fällen der Rückgabewert eben jener Funktion, die aufgerufen wurde.
Die beschriebene Struktur des Servers ist in \cref{lst:server-structure} gezeigt.

\begin{lstlisting}[
  float, caption={Die Kernstruktur des Z3-Servers.}, label={lst:server-structure}, language=C++
]
  int f_id;
  zmsg_t *request = nullptr;
  zmsg_t *response;

  while (true) {
    if (!receive_z3_request(&f_id, &request)) {
      break;
    } // extrahiere Funktionsidentifikator und Nachricht

    response = zmsg_new();
    switch (f_id) {
      case SP_FUNCTION::INIT:
        init_contexts();
        break;
      case SP_FUNCTION::MK_VAR:
        // extrahiere Daten aus Nachricht
        t_type = receive_sp_string(request);
        s_value1 = receive_sp_string(request);
        // rufe Funktion auf und fuege Ergebnis zur Antwort hinzu
        zmsg_addstrf(response, "%ld", mk_var(t_type, s_value1));
        break
      // ...
    }

    send_z3_response(Z3Status::OK, &response);
  }
\end{lstlisting}
\todo[]{erkläre zusätzlichen nachrichtenverkehr in hilfsfunktionen}

Weitere Bestandteile, die zur Struktur des Servers gehören, sind die Initialisierung des Servers, die Verbindungsherstellung zum ProB-Prozess,
das implementierte Logging und die Behandlung von Exceptions.
Diese Aspekte werden in den entsprechenden Abschnitten (\cref{subsec:server-connection}, \cref{subsec:logging}, \cref{sec:exceptions}) genauer erläutert.


\subsection{Implementierung}

blabla

\subsubsection{Interfacefunktionen}

porting of all 53 interface function
start with send and end with receive in ProB
explain necessary structure of request reply (enforced!)
erweiterbarkeit gewährleistet durch injecting des sockets als erster methoden argument



\subsubsection{Hilfsfunktionen}
\label{subsec:helper-functions}

Hilfsfunktionen werden definiert als diejenigen Funktionen, die nicht direkt über das Z3-Interface von ProB aufgerufen werden können,
sondern als Unterstützung für die Implementierung der Interfacefunktionen dienen.
Viele dieser Hilfsfunktionen weisen keine Kopplung zwischen Prolog und Z3 auf und können daher problemlos auf die Z3-Seite portiert werden.
Andererseits gibt es auch Hilfsfunktionen, die eine minimale bis stark enge Kopplung besitzen.
In diesen Fällen ist es notwendig, die Funktionen so zu refaktorisieren, dass sie auf der Z3-Seite ohne Prolog-Abhängigkeiten funktionieren.

Hilfsfunktionen, die nur eine minimale Kopplung aufweisen, benötigen nur wenige Kommunikationsnachrichten zwischen den Prozessen.
Sie lassen sich in den meisten Fällen ähnlich wie die Interfacefunktionen refaktorisieren.
Wichtig zu beachten ist, dass die Hilfsfunktionen inmitten der Funktionskörper der Interfacefunktionen aufgerufen werden.
Da eine strikte Reihenfolge der Nachrichtenübermittlung eingehalten werden muss, ist es notwendig, dass die Hilfsfunktionen
eine invertierte Kommunikationsstruktur verwenden.
Das bedeutet, jede Hilfsfunktion, welche auf einen Nachrichtenaustausch angewiesen ist, ist auf eine Art und Weise zu implementieren,
die immer zuerst eine Nachricht von dem Z3-Server an den ProB-Client sendet.
Gleichermaßen endet jede Hilfsfunktion mit einer Nachricht von ProB an Z3.
Somit ist eine Modularität gewährleistet, durch die jede Hilfsfunktion innerhalb einer Interfacefunktion verwendet werden kann.

Einige Hilfsfunktionen weisen hingegen eine extrem starke Kopplung auf.
Insbesondere ist die Funktion $mk\_type$ hervorzuheben, welche die Typen der in einem Prädikat enthaltenen Elemente konstruiert.
Bei Bedarf dekonstruiert sie den Datentyp von iterierbaren Elementen, wie etwa Listen oder Sets, um an die Typen der wiederum darin enthaltenen Elemente zu gelangen.
Des Weiteren ist die Funktion indirekt rekursiv durch den Aufruf anderer Hilfsfunktionen, welche erneut $mk\_type$ selbst aufrufen.
Die Kopplung zwischen SICStus Prolog und Z3 ist hierbei durch die enthaltenen Bedingungen im Kontrollfluss zusätzlich komplex.
Sowohl die Verwendung von Funktionalitäten der Prolog Bibliothek sowie der Z3-Komponente verändern und bedingen den Verlauf der Methode.
Zur Entkopplung wurde die Logik einer \enquote{State Machine} implementiert, die in verschiedenen Szenarien zusätzliche Informationen
an dem entsprechend anderen Prozess anfordern oder diese an ihn zu senden.
Die Funktion wird in den meisten Interfacefunktionen aufgerufen und ist daher ein zentraler Bestandteil des Z3-Interfaces.
In \cref{fig:mk-type-sequence} ist das Sequenzdiagramm der Hilfsfunktion $mk\_type$ dargestellt, welches die Komplexität der Funktion verdeutlicht
und veranschaulicht, wie die Entkopplung der Funktion durchgeführt wurde.
Auf beiden Seiten des Diagramms sind die ProB- und Z3-Prozesse abgebildet, die schrittweise ihren Zustand ändern, welchen sie durch die Nachrichtenübermittlung synchron halten.

\todo[]{kurz erklären, was passiert}
\begin{figure}[!htp]
  \centering
  \begin{tikzpicture}[scale=3, every node/.style={scale=0.7}]
    % \node at (1,5.4) {\textbf{Sequenz Diagramm der Hilfsfunktion $mk\_type$}};

    \begin{scope}
      \clip (-1,1.3) rectangle (3,6);

      \coordinate (a) at (0,0);
      \coordinate (b) at (0,5);
      \coordinate (c) at (2,0);
      \coordinate (d) at (2,5);
    

      
      \draw (a) -- (b) node[pos=1.03]{\large \textbf{ProB-Client}};
      \draw (c) -- (d) node[pos=1.03]{\large \textbf{Z3-Server}};

      \node[left] at ($(a)!0.955!(b)$) {check if type is atom};
      \node[right] at ($(c)!0.925!(d)$) {check if type exists};
      \node[left] at ($(a)!0.89!(b)$) {return};
      \node[right] at ($(c)!0.87!(d)$) {return};
      \node[left] at ($(a)!0.805!(b)$) {check prolog term};
      \node[right] at ($(c)!0.775!(d)$) {check if type exists};
      \node[left] at ($(a)!0.74!(b)$) {return};
      \node[right] at ($(c)!0.72!(d)$) {return};
      \node[left] at ($(a)!0.685!(b)$) {check iterable type};
      \node[left] at ($(a)!0.56!(b)$) {return};
      \node[right] at ($(c)!0.54!(d)$) {return};

      \draw[stealth-] ($(a)!0.96!(b)$) -- node[above,sloped,midway]{} ($(c)!0.98!(d)$);
      \draw[-stealth] ($(a)!0.95!(b)$) -- node[above,sloped,midway]{it is} ($(c)!0.93!(d)$);
      \draw[stealth-] ($(a)!0.90!(b)$) -- node[above,sloped,midway]{it does} ($(c)!0.92!(d)$);
      \draw[-stealth] ($(a)!0.89!(b)$) -- node[above,sloped,pos=0.4]{} ($(c)!0.87!(d)$);
      
      \draw[-stealth] ($(a)!0.95!(b)$) -- node[below,sloped,pos=0.1]{it is not} ($(c)!0.84!(d)$);
      \draw[stealth-] ($(a)!0.81!(b)$) -- node[above,sloped,midway]{} ($(c)!0.83!(d)$);
      \draw[stealth-] ($(a)!0.81!(b)$) -- node[above,sloped,pos=0.2]{it does not} ($(c)!0.92!(d)$);

      \draw[-stealth] ($(a)!0.80!(b)$) -- node[above,sloped,midway]{} ($(c)!0.78!(d)$);
      \draw[stealth-] ($(a)!0.75!(b)$) -- node[above,sloped,midway]{it does} ($(c)!0.77!(d)$);
      \draw[-stealth] ($(a)!0.74!(b)$) -- node[above,sloped,midway]{} ($(c)!0.72!(d)$);

      \draw[stealth-] ($(a)!0.69!(b)$) -- node[above,sloped,pos=0.2]{it does not} ($(c)!0.77!(d)$);
      \draw[-stealth] ($(a)!0.68!(b)$) -- node[above,sloped,midway]{} ($(c)!0.66!(d)$);
      \draw[stealth-] ($(a)!0.63!(b)$) -- node[above,sloped]{} ($(c)!0.65!(d)$);

      \path[draw,dashed,->] ($(a)!0.68!(b)$) arc[start angle=270, end angle=90, radius=0.75] node[pos=0.4, right]{set};
      \path[draw,dashed,->] ($(c)!0.65!(d)$) arc[start angle=270, end angle=450, radius=0.85] node[pos=0.3, left]{set};

      \draw[-stealth] ($(a)!0.62!(b)$) -- node[above,sloped,midway]{global atom} ($(c)!0.60!(d)$);
      \draw[stealth-] ($(a)!0.57!(b)$) -- node[above,sloped,midway]{} ($(c)!0.59!(d)$);
      \draw[-stealth] ($(a)!0.56!(b)$) -- node[above,sloped,midway]{} ($(c)!0.54!(d)$);

      \draw[-stealth] ($(a)!0.62!(b)$) -- node[above,sloped,pos=0.65]{couple} ($(c)!0.52!(d)$);
      \draw[stealth-] ($(a)!0.49!(b)$) -- node[above,sloped]{} ($(c)!0.51!(d)$);
      \draw[-stealth] ($(a)!0.48!(b)$) -- node[above,sloped]{} ($(c)!0.46!(d)$);

      \path[draw,dashed,->] ($(a)!0.48!(b)$) arc[start angle=270, end angle=90, y radius=1.25, x radius=1] node[pos=0.33, right]{couple elements};
      \path[draw,dashed,->] ($(c)!0.46!(d)$) arc[start angle=270, end angle=450, y radius=1.325, x radius=1] node[pos=0.35, left]{couple elements};

      \draw[-stealth] ($(a)!0.62!(b)$) -- node[above,sloped,pos=0.55]{record} ($(c)!0.44!(d)$);
      \draw[stealth-] ($(a)!0.41!(b)$) -- node[above,sloped]{} ($(c)!0.43!(d)$);
      \draw[-stealth] ($(a)!0.40!(b)$) -- node[above,sloped]{next list element} ($(c)!0.38!(d)$);
      \draw[stealth-] ($(a)!0.35!(b)$) -- node[above,sloped]{} ($(c)!0.37!(d)$);
      \draw[-stealth] ($(a)!0.34!(b)$) -- node[above,sloped]{} ($(c)!0.32!(d)$);
      \draw[stealth-] ($(a)!0.29!(b)$) -- node[above,sloped]{} ($(c)!0.31!(d)$);
      \draw[-stealth] ($(a)!0.40!(b)$) -- node[above,sloped,pos=0.55]{list empty} ($(c)!0.27!(d)$);

      \path[draw,dashed,->] ($(a)!0.29!(b)$) arc[start angle=270, end angle=90, y radius=0.285, x radius=0.3] node[midway, left]{};
      \path[draw,dashed,->] ($(c)!0.31!(d)$) arc[start angle=270, end angle=450, y radius=0.16, x radius=0.3] node[midway, right]{};

      \path[draw,dashed,->] ($(a)!0.40!(b)$) arc[start angle=270, end angle=90, y radius=1.45, x radius=1] node[midway, left]{};
      \path[draw,dashed,->] ($(c)!0.27!(d)$) arc[start angle=270, end angle=450, y radius=1.8, x radius=1] node[midway, right]{};

    \end{scope}

  \end{tikzpicture}
  \caption{Sequenz Diagramm der Hilfsfunktion $mk\_type$}
  \label{fig:mk-type-sequence}
\end{figure}



\subsubsection{Optimierungen}
\label{subsec:optimizations}
\todo[]{bessere codeschnipsel!}
Nach der erfolgreichen Portierung der Schnittstelle und der Implementierung aller notwendigen Funktionen
lassen sich zusätzlich kleine Optimierungen und Verbesserungen vornehmen, um Effizienz, Lesbarkeit und Wartbarkeit des Codes zu erhöhen.

Eine der elementarsten Optimierungsmöglichkeiten ist die Vermeidung von Nachrichtenaustausch beider Prozesse
innerhalb von Schleifen. Dieses Verhalten tritt insbesondere dann auf, wenn Prolog Datenstrukturen übermittelt werden,
die iterierbar sind, wie Listen, Vektoren und Records.
In diesen Fällen wird für jedes Element der Struktur eine Nachricht an den Server gesendet,
um das aktuelle Element zu übermitteln.
Dieses Verhalten kann in einzelnen Fällen durch die Übermittlung der gesamten Struktur in einer einzigen Nachricht vermieden werden.
In dem Folgenden \cref{lst:loops-optimization} ist gezeigt, wie eine Prolog Liste zunächst in einem String Vektor akkumuliert wird,
um anschließend in einer einzigen Nachricht an den Server gesendet zu werden.

\begin{lstlisting}[
    float, caption={Ein Ausschnitt einer Interfacefunktion zur Demonstration von Schleifenoptimierung.}, label={lst:loops-optimization}, language=C++
  ]
  std::vector<std::string> string_vec = 
    term_ref_prolog_list_to_string_vector(element_names);
  for (int i = 0; i < cardinality; i++) {
      zmsg_addstr(request, string_vec[i].c_str());
  }
  // send request to server
\end{lstlisting}
\todo[]{anpassen an letzte refaktorisierung!}
Eine weitere Optimierungsmöglichkeit ist die Vermeidung von unnötigen Nachrichten an den Server.
Beispielsweise illustriert \cref{lst:unnecessary-ctx-data} vermeidbare Komplexität durch die Verwendung unnötiger Datenobjekte.
Anhand der Variablen $translation\_type\_atom$ wird das Objekt $ctx\_data$ ermittelt, welches an die Funktion $prolog\_type\_list\_to\_sort\_vector$ übergeben wird.
Diese verwendet das Objekt ausschließlich zur Ermittlung der Variablen $translation\_type\_atom$. Das Problem hierbei ist,
dass $ctx\_data$ in der neuen Architektur auf der Seite des Server-Prozesses liegt und somit einen Nachrichtenaustausch erfordert.
Das Problem lässt sich umgehen, indem die Funktion $prolog\_type\_list\_to\_sort\_vector$ dahingehen refaktorisiert wird,
direkt mit $translation\_type\_atom$ aufgerufen zu werden oder sogar gänzlich darauf zu verzichten.

\begin{lstlisting}[
    float, caption={Ein Ausschnitt einer redundanten Objektverwaltung.}, label={lst:unnecessary-ctx-data}, language=C++
  ]
  // function: mk_op_comprehension_set_multi
  ContextData ctx_dta =
    get_translation_representant_ctx_data(translation_type_atom);
  prolog_type_list_to_sort_vector(ctx_data, couple_types);
  // ...
  
  // function: prolog_type_list_to_sort_vector
  mk_sort(ctx_data->get_translation_type_atom());
  
\end{lstlisting}

\begin{lstlisting}[
    float, caption={Die Hilfsfunktion $escape\_string$.}, label={lst:escape-string}, language=C++
  ]
  std::string escape_string(const std::string to_escape) {
    return "|" + to_escape + "|";
  }
\end{lstlisting}

Zuletzt wurde das DRY\footnote{Don't Repeat Yourself}-Prinzip angewendet, um die Wartbarkeit des Codes zu erhöhen,
indem gewisse Hilfsfunktionen ausschließlich auf entweder der Prolog- oder der Serverseite implementiert wurden.
Der ursprüngliche Kontrollfluss verlangte zum Beispiel die Implementierung von der in \cref{lst:escape-string} gezeigten Funktion
in beiden Prozessen. Durch die Anwendung des Programmierprinzips und minimaler Anpassung im Quellcode wurde die Funktion ausschließlich innerhalb des Z3-Prozesses implementiert.
\todo[]{perhaps we do not need this stupid example}

\subsubsection{Serveranbindung}
\label{subsec:server-connection}

Der Z3-Prozess wird nicht manuell gestartet, sondern,
um eine angenehme Nutzerfreundlichkeit zu gewährleisten, automatisch im Z3-Interface als Subprozess von ProB erzeugt.
Insbesondere bedeutet das, dass der Z3-Server ausschließlich auf Anfrage von ProB gestartet wird, wenn das entsprechende Interface verwendet wird.
Der Z3-Solver existiert somit als Subprozess von ProB und wird mit dessen Beendigung ebenfalls terminiert.
Dieses Verhalten ist innerhalb der Prolog-Seite des Z3-Interfaces implementiert und wird durch das Prädikat $init\_z3interface$ realisiert, welches dahingehend erweitert wurde.
Die Implementierung des Prädikats ist in \cref{lst:init-z3interface} gezeigt.

\begin{lstlisting}[
  float, caption={Das Prädikat zur Initialisierung des Z3-Interfaces.}, label={lst:init-z3interface}, language=Prolog
]
init_z3interface :- is_initialised(_), !.
init_z3interface :-
    catch(load_foreign_resource(library(z3interface)),E,
          (format(user_error,'*** LOADING Z3 library failed~n',[]),
           assert(z3_init_exception(E)),
           fail)
          ),
    get_path_to_fresh_z3_endpoint(Endpoint),
    process_create('./lib/z3rver', [Endpoint], [stdout(null)]),
    init(Endpoint, Zocket),
    assertz(is_initialised(Zocket)).
\end{lstlisting}
\todo[]{verify tmp file lib name}
In den entsprechenden Zeilen 8 bis 10 wird der Endpoint zur ZeroMQ Kommunikation generiert
und als Funktionsargument an die $init$ Funktion übergeben, welche die Verbindung zum Z3-Server herstellt.
Die Funktion $process\_create$ wird eingesetzt, um den Z3-Server als Subprozess zu starten,
welcher durch die Verwendung der Systemargumente ebenfalls über den generierten Endpoint informiert wird.
So sind beide Prozesse in Kenntnis desselben Endpoints und können miteinander kommunizieren.
Der Endpoint selbst ist hierbei effektiv ein Pfad zu einer temporären Datei, die als Kommunikationskanal zwischen den Prozessen dient.
Er wird innerhalb von $get\_path\_to\_fresh\_z3\_endpoint$ mit Hilfe der Prolog Bibliothek $tmp\_file$ generiert.

\subsubsection{Logging}
\label{subsec:logging}

via sys argv
stdout not captureable in sicstus prolog



